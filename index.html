<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quasistatic Wakefields 1D</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 800px;
      margin: auto;
    }
    .slider-container {
      margin-top: 20px;
    }
    .slider-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .output {
      margin-top: 40px;
      text-align: center;
    }
    img {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Quasistatic Wakefields 1D</h1>
    <p>Created by Emily Archer, 2025</p>
    
    <!-- Sliders -->
    <div class="slider-container">
      <label for="omega0">Omega0 (Normalized Laser Frequency): <span id="omega0-value">15</span></label>
      <input id="omega0" type="range" min="15" max="50" step="1" value="15">
    </div>
    <div class="slider-container">
      <label for="a01">a01 (Drive Pulse Amplitude): <span id="a01-value">1</span></label>
      <input id="a01" type="range" min="0" max="2" step="0.1" value="1">
    </div>
    <div class="slider-container">
      <label for="tau1">Tau1 (Pulse Duration): <span id="tau1-value">1</span></label>
      <input id="tau1" type="range" min="0.2" max="20" step="0.2" value="1">
    </div>

    <!-- Output -->
    <div class="output">
      <img id="plot" alt="Plot will be displayed here">
    </div>
  </div>

  <script type="text/javascript">
    async function main() {
      try {
        const pyodide = await loadPyodide();
        console.log("Pyodide loaded successfully!");

        // Load required Python packages
        await pyodide.loadPackage(["numpy", "matplotlib"]);
        console.log("Required Python packages loaded successfully!");

        // Define Python code as a string
        const pythonCode = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64
"DEFINE CONSTANTS"
cm = 1e-2
mm = 1e-3
um = 1e-6
nm = 1e-9
ps = 1e-12
fs = 1e-15
mJ = 1e-3
c = 2.998e8

# Conversions to real SI units (rest of code normalised to plasma )
def generate_parameters(n_0):
    k_p = np.sqrt(
        4.0 * np.pi * e**2 * n_0 * 1e6 / (m_e * c**2)
    )  # Plasma wavenumber [m^-1]
    omega_p = np.sqrt(4.0 * np.pi * e**2 * n_0 * 1e6 / m_e)  # Plasma frequency [s^-1]
    lambda_p = 2.0 * np.pi * c / omega_p  # Plasma wavelength [m]
    E0 = c * m_e * omega_p / e  # Cold non-relativistic wavebreaking field [Vm^-1]
    return k_p, omega_p, lambda_p, E0


def normalised_parameters(v, A, Phi, E, p):
    beta = v / c
    a0 = e * A / (m_e * c)
    phi = e * Phi / (m_e * c**2)
    gamma = E / (m_e * c**2)
    u = p / (m_e * c)
    return beta, a0, phi, gamma, u


def SI_parameters(beta, a0, phi, gamma, u):
    v = beta * c
    E = a0 * m_e * c / e
    Phi = phi * m_e * c**2 / e
    E = gamma * m_e * c**2
    p = u * m_e * c
    return v, A, Phi, E, p


def energy(intensity,axes,NormalisationFactor=False): # Calculates the total energy of the field from the intensity map
    for axis in axes:
        intensity*=axis
    if NormalisationFactor: # Calculates instead the factor to multiply field by to normalise total energy
        return np.sqrt(np.sum(intensity))
    else:
        return np.sum(intensity)

def plot_wakefield2(
    omega0=15, a01=1, tau1=1, tau_delay1=0, a02=0.5, tau2=1, tau_delay2=1):
    
    n_0=1.0e17
    omega_L = 2*np.pi*c/(800*nm)
    k_p, omega_p, lambda_p, E0 = generate_parameters(n_0)
    tau_p = 2.*np.pi / omega_p
    
    tau_delay1*=2.*np.pi
    tau_delay2*=2.*np.pi
    
    # Calculate coordinates
    xi = np.linspace(- lambda_p, 4. * lambda_p, 1000)  # Moving frame coordinate
    psi = k_p * xi   # Normalised moving frame coordinate
    psi_plot = - psi / (2. * np.pi) + k_p * tau_delay1 / (2. * np.pi) # Axis for plotting
        
    # Laser vector potential 
    def a_1(psi):
        field = (
            a01
            * np.exp(- 2. * np.log(2) * ((psi - tau_delay1) ** 2) / (tau1) ** 2)
            * np.exp(- 1j * omega0 * psi)
        )
        return np.real(field)
        
    def a_2(psi):
        field = (
            a02
            * np.exp(- 2. * np.log(2) * ((psi - (tau_delay1 + tau_delay2)) ** 2) / (tau2) ** 2)
            * np.exp(- 1j * omega0 *  psi)
        )
        return np.real(field)

    # Laser envelopes
    def a_01(psi):
        field = (
            a01
            * np.exp(- 2. * np.log(2) * ((psi - tau_delay1) ** 2) / (tau1) ** 2)
        )
        return field
    
    def a_02(psi):
        field = (
            a02
            * np.exp(- 2. * np.log(2) * ((psi - (tau_delay1 + tau_delay2)) ** 2) / (tau2) ** 2)
        )
        return field


    # Sinusoidal laser envelope
    def a_s(psi):
        env1 = a01 * np.sin(np.pi * psi / tau1)
        if hasattr(psi, "__len__"):
            env1[psi > tau1] = 0
        elif psi > tau1:
            env1 = 0

        env2 = a02 * np.sin(np.pi * psi / tau2)
        if hasattr(psi, "__len__"):
            env2[psi > tau2] = 0
        elif psi > tau2:
            env2 = 0
        return env1 + env2

    def linear_wake(x, psi):
        return [x[1], k_p**2 * (a(psi) ** 2 - x[0])]

    def non_linear_wake_approx(x, psi):
        return [x[1], k_p**2 / 2.0 * ((1 + a(psi) ** 2) / (1 + x[0]) ** 2 - 1)]

    def non_linear_wake_esarey(x, psi):
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        Omega = (1.0 + x[0])
        a = a_1(psi) + a_2(psi)
        return [
            x[1],
            (k_p * gamma_p) ** 2
            * (
                beta_p
                / np.sqrt(1.0 - (1.0 +  a**2) / (gamma_p**2 * Omega ** 2))
                - 1.0
            ),
        ]

    def non_linear_wake(x, psi):
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        Omega = (1.0 + x[0])
        a = a_1(psi) + a_2(psi)
        Psi = np.sqrt(1.0 - (1.0 + a**2)/(gamma_p**2 * Omega**2))
        return [
            x[1],
            (k_p) ** 2
            * (
                beta_p * (1.0 + a** 2) - Omega**2 * Psi
            ) / (
                Omega**2 * Psi + beta_p * Omega**2 * Psi**2
            ),
        ]

    def Hamiltonian(
        u, psi, phi
    ):  # Defines the Hamiltonian of the electron motion in non-linear wake
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        gamma_perp = (1.0 + a_01(psi) ** 2)
        u = u / (beta_p * gamma_p)
        return np.sqrt(gamma_perp**2 + u**2) - beta_p * u + phi

    def Hamiltonian_s(psi_min, phi_min):  # Defines the separatrix
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)  # !! Note c=1 so k_p/c=k_p
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        gamma_perp = 1 + a_01(psi_min) ** 2 / 2.0
        return gamma_perp / gamma_p - phi_min

    def trajectory_p(psi, H, phi):
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        return np.real(
            beta_p * gamma_p**2 * (H + phi)
            + gamma_p
            * np.sqrt((gamma_p**2 * (H + phi) ** 2 - (1.0 + a1(psi)) ** 2) + 0 * 1j)
        )

    def trajectory_m(psi, H, phi):
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        return np.real(
            beta_p * gamma_p**2 * (H + phi)
            - gamma_p
            * np.sqrt((gamma_p**2 * (H + phi) ** 2 - (1.0 + a1(psi)) ** 2) + 0 * 1j)
        )


    def trajectory_s(psi, H, phi):
        beta_p = np.sqrt(1 - (k_p / omega0) ** 2)
        gamma_p = 1.0 / np.sqrt(1 - beta_p**2)
        return np.real(
            beta_p * gamma_p**2 * (H + phi)
        )

    # Solve 1D non-linear ODE for the wake
    # Change the equation to be solved in the following line (e.g. linear, non-linear approx., non-linear)
    # Non-linear and approx given and referenced in Esarey et al. (2009)
    # Linear from Najmudin, CAS-CERN (2016)
    phi, phi_ = odeint(non_linear_wake, [2e-9, 0], psi).T
    _, phi__ = non_linear_wake([phi, phi_], psi)

    # Calculate wakefield, density and Hamiltonian
    Ez = -1.0 / k_p * phi_  # Wakefield
    ne = 1.0 / k_p**2 * phi__ # Electron density, delta n_e/n_0
    
    phi_min = np.min(phi)  # Minimum wake potential
    psi_min = np.argsort(phi)[1]  # Index of minimum trapping phase
    H_i = 1 - phi # Intital Hamiltonian for particle at any position
    H_s = Hamiltonian_s(psi_min, phi_min)  # Separatrix

def plot_wakefield(omega0, a01, tau1):
    n_0 = 1.0e17
    k_p, omega_p, lambda_p, E0 = generate_parameters(n_0)
    xi = np.linspace(-lambda_p, 4. * lambda_p, 1000)
    psi = k_p * xi
    phi = np.sin(psi * omega0 / 15) * np.exp(-a01 * psi / lambda_p)

    plt.figure(figsize=(8, 4))
    plt.plot(psi, phi, label="Wakefield Potential")
    plt.xlabel("xi")
    plt.ylabel("Potential (phi)")
    plt.title(f"Wakefield Simulation (omega0={omega0}, a01={a01}, tau1={tau1})")
    plt.legend()
    plt.grid(True)
    buf = BytesIO()
    plt.savefig(buf, format="png")
    buf.seek(0)
    img_str = base64.b64encode(buf.read()).decode("utf-8")
    return img_str
        `;

        // Load Python code into Pyodide
        await pyodide.runPythonAsync(pythonCode);
        console.log("Python code loaded successfully!");

        // Function to update the plot based on slider values
        async function updatePlot() {
          const omega0 = document.getElementById("omega0").value;
          const a01 = document.getElementById("a01").value;
          const tau1 = document.getElementById("tau1").value;

          // Update slider values displayed in labels
          document.getElementById("omega0-value").innerText = omega0;
          document.getElementById("a01-value").innerText = a01;
          document.getElementById("tau1-value").innerText = tau1;

          // Generate the plot using Python code
          const plotCode = `
img_base64 = plot_wakefield(${omega0}, ${a01}, ${tau1})
img_base64
          `;
          const output = await pyodide.runPythonAsync(plotCode);

          // Display the plot as an image
          const imgElement = document.getElementById("plot");
          imgElement.src = "data:image/png;base64," + output;
          console.log("Plot updated!");
        }

        // Add event listeners to sliders
        document.getElementById("omega0").addEventListener("input", updatePlot);
        document.getElementById("a01").addEventListener("input", updatePlot);
        document.getElementById("tau1").addEventListener("input", updatePlot);

        // Generate the initial plot
        updatePlot();
      } catch (error) {
        console.error("Error during initialization:", error);
      }
    }

    main();
  </script>
</body>
</html>